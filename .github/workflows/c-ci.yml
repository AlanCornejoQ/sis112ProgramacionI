name: C CI (src/inc + múltiples inputs)

on:
  push:
    paths:
      - "c/**"
      - ".github/workflows/c-ci.yml"
  pull_request:
    paths:
      - "c/**"
      - ".github/workflows/c-ci.yml"

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Compilar y probar ejercicios
        shell: bash
        run: |
          set -euo pipefail
          shopt -s globstar nullglob

          # Recorre tareas y exámenes (usa el que prefieras: examen o examenes)
          for base in c/tareas/** c/examen/** c/examenes/**; do
            [[ -d "$base/src" ]] || continue

            echo "=== Construyendo $base ==="
            mkdir -p "$base/build"

            # Todos los .c bajo src/
            SRC_FILES=( "$base"/src/**/*.c )
            if (( ${#SRC_FILES[@]} == 0 )); then
              echo "No se encontraron .c en $base/src, se omite."
              continue
            fi

            # Compilar (incluye headers si existen)
            if [[ -d "$base/inc" ]]; then
              gcc "${SRC_FILES[@]}" -I "$base/inc" -O2 -o "$base/build/app"
            else
              gcc "${SRC_FILES[@]}" -O2 -o "$base/build/app"
            fi

            echo "--- Ejecutando pruebas en $base ---"

            ran_any_test=false

            # 1) Casos con múltiples inputs: input_*.txt ↔ expected_*.txt
            INPUTS=( "$base"/input_*.txt )
            if (( ${#INPUTS[@]} )); then
              for infile in "${INPUTS[@]}"; do
                testname="$(basename "$infile" .txt)"
                # toma el sufijo después del primer guion bajo: input_3 -> 3
                id="${testname#input_}"
                expfile="$base/expected_${id}.txt"
                echo ">> Caso input_${id}"
                "$base/build/app" < "$infile" > "$base/build/out_${id}.txt"

                if [[ -f "$expfile" ]]; then
                  # Normalizar (quita CR y asegura \n final) para evitar falsos diffs
                  tr -d '\r' < "$expfile" | sed -e '$a\' > "$base/build/expected_${id}_norm.txt"
                  tr -d '\r' < "$base/build/out_${id}.txt" | sed -e '$a\' > "$base/build/out_${id}_norm.txt"
                  diff -u "$base/build/expected_${id}_norm.txt" "$base/build/out_${id}_norm.txt"
                else
                  echo "ADVERTENCIA: No existe $expfile. Se muestra la salida generada:"
                  cat "$base/build/out_${id}.txt"
                fi
              done
              ran_any_test=true
            fi

            # 2) Caso único con expected.txt (si no hubo múltiples inputs)
            if [[ "$ran_any_test" == false && -f "$base/expected.txt" ]]; then
              "$base/build/app" > "$base/build/out.txt"
              tr -d '\r' < "$base/expected.txt" | sed -e '$a\' > "$base/build/expected_norm.txt"
              tr -d '\r' < "$base/build/out.txt" | sed -e '$a\' > "$base/build/out_norm.txt"
              echo ">> Comparando salida con expected.txt"
              diff -u "$base/build/expected_norm.txt" "$base/build/out_norm.txt"
              ran_any_test=true
            fi

            # 3) Si no hay expected(s), solo ejecutar
            if [[ "$ran_any_test" == false ]]; then
              echo ">> Sin expected(s). Ejecutando binario:"
              "$base/build/app"
            fi

            echo "=== OK: $base ==="
          done
